%% LyX 2.2.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm,headheight=3cm,headsep=3cm}
\usepackage{float}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{babel}





\usepackage{babel}

\makeatother

\usepackage{babel}
\begin{document}

\section{Ejercicio 6: Implementación de una ALU}
\noindent \begin{flushleft}
Para este ejercicio se pidió implementar una ALU de 4 bits con las
operaciones SUMA, RESTA, AND, OR, NOT, XOR, Complemento a dos y Shift
Left. Para esto se decidió crear un modulo encargado de sumar 2 bits,
este a su vez devuelve un bit de respuesta y un bit de carry. Utilizando
ese modulo, se procedió a hacer un nuevo modulo que haga una suma
de 3 bits. Esta decisión simplificó mucho el desarollo del modulo
de suma de la ALU de 4 bits, ya que como se puede ver en el código
``sum.v'' encontrado en la carpeta src, se puede ver comentado dentro
del código como fue nuestro desarrollo sin la función sum3Bits y como
quedo finalmente el código con la implementacion de sum3Bits. 
\par\end{flushleft}

\noindent \begin{flushleft}
Para el caso de la resta se decidió utilizar el modulo hecho en el
ejercicio 4 del complemento a 2 y así, se utilizó en conjunto ese
modulo con el modulo suma. 
\par\end{flushleft}

\noindent \begin{flushleft}
En el caso de las operaciones AND, OR, NOT y XOR, se opto por utilizar
las funciones predefinidas por verilog y reutilizarlas bit a bit. 
\par\end{flushleft}

\subsection{Definiciones}

Esta unidad aritmetica lógica se implemento con 2 acumuladores (que
llamaremos A y B en este orden) de 4 bits cada uno, tres bits de operaciones,
4 bits del acumulador de salida (que llamaremos Acumulador C) y un
bit de carry, ordenados en el orden en que fueron mencionados. Para
seleccionar que operacion se desea hacer, se deben encender los 3
bits de operaciones de la siguiente manera:

\begin{table}[H]
\begin{centering}
\begin{tabular}{|c|c|c|c|}
\hline 
 & Bit 0 & Bit 1 & Bit 2\tabularnewline
\hline 
\hline 
AND & 0 & 0 & 0\tabularnewline
\hline 
NOT & 0 & 0 & 1\tabularnewline
\hline 
OR & 0 & 1 & 0\tabularnewline
\hline 
XOR & 0 & 1 & 1\tabularnewline
\hline 
SHIFT LEFT & 1 & 0 & 0\tabularnewline
\hline 
SUM & 1 & 0 & 1\tabularnewline
\hline 
SUBSTRACTION & 1 & 1 & 0\tabularnewline
\hline 
TWO'S COMPLEMENT & 1 & 1 & 1\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{Representacion de operaciones en los bits.}
\end{table}
\begin{itemize}
\item AND: Realiza una operacion AND bit a bit entre acumuladores A y B
y la devuelve en el acumulador C, a su vez, el carry se devuelve en
cero.
\item NOT: Realiza una operacion logica NOT bit a bit del acumulador A y
devuelve la respuesta en el acumulador C, a su vez, el carry queda
en cero.
\item OR: Realiza una operacion OR bit a bit entre acumuladores A y B y
la devuelve en el acumulador C, a su vez, el carry se devuelve en
cero.
\item XOR: Realiza una operacion XOR bit a bit entre acumuladores A y B
y la devuelve en el acumulador C, a su vez, el carry se devuelve en
cero.
\item SHIFT LEFT: Se encarga de mover cada bit del acumulador A un espacio
a la derecha e inserta un cero al bit menos significativo, la respuesta
la devuelve en el acumulador C y el carry valdra 0 o 1 dependiendo
del bit mas significativo de A
\item SUM: Se encarga de hacer una suma numerica de los valores decimales
de los acumuladores A y B y devuelve el resultado (en codigo binario)
en el acumulador C. Dependiendo si es representable el resultado de
la suma en un nibble se encendera o no el bit Carry.
\item SUBSTRACTION: Se encarga de hacer una resta numerica de los valores
decimales de los acumuladores A y B y devuelve el resultado (en codigo
binario) en el acumulador C. El carry se devuelve en 1.
\item TWO'S COMPLEMENT: Se encarga de hacer el complemento a 2 del acumulador
A y devuelve el resultado en el acumulador C. El carry se devuelve en cero.
\end{itemize}

\end{document}
